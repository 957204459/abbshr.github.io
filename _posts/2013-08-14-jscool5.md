---
layout: poslay
title: Little JavaScript Book『伍』———诡异特性（隐式类型转换篇-续）
label: 酷玩JavaScript
kind: label-important
ptr: JavaScript
mdmark: ran
metakey: JavaScript,酷玩,教程,SouFii,blog,个人博客
metades: JavaScript花式玩法『伍』———诡异特性（隐式类型转换篇-续），SouFii的博客
---

要弄明白数据类型在不同的运算中是如何被转换的，有必要了解内部实现机制~  
这篇PO中会详细说明对象与原始值间的隐式互相转化机理。的确，我们平时基本上不弄这些东西。但是，记住。我们是‘要酷’玩，耐心读下去~~可能会感觉很乱，建议对照上一篇PO来理解。

不知你是否听过或见过类似‘拼凑ID名字’、‘混乱代码大赛’之类的怪味游戏。混乱代码我不必解释，名字拼凑也是很好玩的，应该也属于混乱代码的一个小分支吧。就是让你用各种复杂令人费解的代码（当然越蹩脚越好）生成一个你想要的‘字符串’、‘动态图形’、‘字符图片’等等，不过不是要你在代码中用明文写出那些字符，而是用代码的运算通过机器去生成！怎么样，够酷吧？

我刚刚拿些操作符组合弄了个例子：

	(![] + [])[++[-~!![]][+[]]][+[]] + ({} + [])[-~![]] + ([][+[]] + [])[+[]] + (![] + [])[+[]] + (-~[]/+[] + [])[++[-~!![]][+[]]] + (-~[]/+[] + [])[++[-~!![]][+[]]]

	//这段代码的返回结果是我的ID字符串“soufii”
	//其中就应用了隐式类型转换中的值与类型问题

待会儿我们再说其机密~~好！开始说正经的了~

##对象向原始值的转化

首先你要知道，任何对象`{}`都有两个原始的方法`toString()`和`valueOf()`，继承自原型链的顶端——`Object.prototype`对象。当对象做隐式转换时，首先会自动判断将要转化为什么类型，然后按规则调用上述两个方法。规则如下：

1. 如果对象要被转化为布尔型，最简单：所有引用类型或者说对象都转换成true。
2. 如果转化为字符串：若有toString()方法，则调用，当该方法返回原始值时被转化为字符串，最终返回这个字符串。若没有这个方法或者该方法返回的并不是原始值，则调用valueOf()方法，如果它返回原始值则被转化为字符串并最终返回该字符串，否则转化出错，抛出TypeError。
3. 如果转化为数字：和上面的情况相似，只不过先检查valueOf()后检查toString()，然后将原始值转化为数字而已，否则抛出TypeError。

##原始值向对象的转化
其实这段应该属于下一个PO的，不过为了对应上还是先写出来了。。	
分别用`Number()`、`Boolean()`、`String()`的构造函数（不加new则变成类型转换函数！）对对应类型的原始值进行处理即可，这种方式得到的对象被称作**包装/封装对象**，意为“在原始值的基础上进行外包装，使其拥有普通对象的特征与能力”，因而这种**‘包装对象’** 和 **‘临时对象’** 之间有着本质的差别： **对象可被改变**。  
ex:

	new Number(2);
	new Boolean(false);
	new String('ran');

这就是JavaScript在类型转化上的灵活！

##显式类型转换
还有一种显式的类型转换，这种转换是人为的：为了使某个类型值转化为指定类型，在正式开发中经常使用。  
这篇PO暂时不讨论，会在后面的‘显式转化：对象封装、临时对象与利用隐式转化’一节中做完整说明。
　
