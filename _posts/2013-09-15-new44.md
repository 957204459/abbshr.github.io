---
layout: poslay
title: 谈谈Node.js
label: Node
kind: label-important
ptr:
mdmark:
metakey:
metades:
---

##理解Node
其实无非就是要对下面提到的这些有所了解。  
首先要了解的是：`require`不会重复加载模块，也就是说无论调用多少次require获得的模块都是同一个。  
其次，在浏览器JavaScript中,通常 `window` 是全局对象,而 Node.js 中的全局对象是 `global`。  
上面这些在后面的开发手记PO中我会慢慢说，然后要说的就是从前端JavaScript进军后端必须理解的—Node核心的异步无阻塞I/O模型了。

###异步I/O模型
所谓的**I/O** 是对 **磁盘读写** 或 **网络通信** 的统称。异步式I/O(Asynchronous I/O)或非阻塞式I/O(Non-blocking I/O)即针对所有I/O操作**不采用阻塞**的策略：当线程遇到I/O操作时,不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发送给操作系统,并继续执行下一条语句，异步I/O操作在完成时都会发送一个事件到**事件队列**，并进入**事件循环**，事件循环会检查事件队列中有没有未处理的事件，直到程序结束，如果有的话，Node主线程会在空闲时处理这个事件。

###常见误解
1.node.js的单线程无阻塞模型常常被人误解。其实上面已经阐明了，当阻塞请求发生时，node.js只是在事件队列中注册一个事件，然后继续其他操作，而具体这个事件的执行就交给了操作系统的不同的进程，等I/O完成后，通过回调再回到主线程处理，所以node.js单线程是指自己的主线程，而**不是所有的操作都是在这个线程里**，这个线程只是事件调度， **事件的执行都是交给操作系统在其它的线程中完成**。  
2.而**异步**执行也不是指所有代码，而是特指**I/O操作**，除了I/O之外，其余代码都是**“阻塞”**的，因此不必担心每行代码都一瞬间执行而导致后面的代码无法正常的接收消息。

因此，Node.js 适合**I/O 密集型**的应用，而不是**计算密集型**的应用，因为一个 Node.js 进程只有一个线程，因此在任何时刻都只有一个事件在执行。如果这个事件占用大量的 CPU 时间，执行事件循环中的下一个事件就需要等待很久。

##Node的优与劣
如今JavaScript应用铺天盖地，Node.js平台的出现，打破了JavaScript只能用在前端的诅咒，其优雅与高效着实吸引了不少人的青睐（包括我在内），但是再好的东西也有它的不足，Node也并不是什么都能胜任的，下面就分析一下Node的优与劣。

###适合使用 Node.js 的情况

1. 构建（软）实时社交应用程序，如 Twitter 或聊天应用程序。
2. 构建性能卓越、I/O 速度高的 TCP 应用程序，如代理服务器、PaaS、数据库等。
3. 构建后端日志记录和处理应用程序。
4. 构建与 vmc-tool 类似的绝佳 CLI 应用程序，以及诸如 ant 或 Make 之类的工具。
5. 在应用程序服务器前添加采用 REST 且基于 API 的 Web 服务器。

###不适合使用 Node.js 的情况

1. 它不适合任务关键型（硬）实时应用程序（如心跳监控应用程序）或需要占用大量 CPU 资源的应用程序。
2. 对于不具有任何实时或高性能需求的简单 CRUD 应用程序，Node.js 与其他语言相比并不能提供太大的优势。
3. 对于可能需要某些特定库的企业级应用程序，可能尚未有合适的 Node.js 库出现。（不过，可以构建一款支持多种语言的应用程序，从而将 Java 与 Node.js 结合使用来帮助构建库。）

###Node.js 的缺点
大多数缺点都是因为 Node.js 本身还相对较新：  
Node.js 库正在积极开发，更改率非常高。几乎每月都会有更新版本的库出现。这可能会造成版本问题和不稳定性。不久前已经推出了 Npm shrinkwrap 和 package.json 来建立标准，但此问题依然存在。  
仍有很多库（例如企业级应用程序需要的 SAML 身份验证库）尚未提供。  
Node.js 的回调、事件驱动、函数式编程等所有这些方面可能会增加采用其他面向对象的语言的服务器端程序员的学习负担。（请注意，有一些库可以帮助克服此困难。async 就是其中之一。此外，开发人员还可以使用可编译成 JavaScript 的 CoffeeScript 来帮助学习）。异步且由事件驱动的代码与同步代码相比，本身就会增加代码的复杂性。（说实话，其实我并不这么觉得！）