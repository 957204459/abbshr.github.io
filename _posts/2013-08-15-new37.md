---
layout: poslay
title: 事件驱动编程与JavaScript
label: 编程范式
kind: label-warning
ptr: 
mdmark: 
metakey: 
metades:
---

###事件驱动的模型

基于事件驱动的程式我们常常接触，尤其是在用户图形界面(GUI)环境中，每单击一次鼠标、敲一下键盘或是当一个模块加载完毕时，都伴随着事件的产生，——操作系统就是个典型的例子。

最近在学习JavaScript的事件模型，再次接触到“事件”这一概念，便整理了一些资料，写了这篇博客，加深理解。

所谓事件驱动的，即：事件的触发导致程式执行。  
在这样一种编程范式中，程式的代码并非像过程化编程那样按“自顶向下、逐步求精”的顺序来执行。因为在事件模型中，每个事件都是随机的、不定发生的，因此开发人员无法预知整个程式将要完成什么任务，所以程式的代码也无法按正常顺序逐步执行。事件驱动编程中代码段的执行靠不同事件的响应来完成，这里有几个事件驱动的模型核心构成：

* 事件注册
* 轮询
* 触发
* 事件处理

事件驱动编程也正是由这几点支撑起来的。  
每个事件在生效前都需要向系统申请**注册**，并编写事件处理函数来**Handle**这个事件。当这个事件被**触发**时，事件处理函数将会被执行。而永无止境的事件**轮询**是完成这一系列动作基础。  
事件驱动编程的关键就在事件的处理上，整个程式的代码都是为了处理相应事件而编写的。

###JavaScript中的事件模型

JavaScript除了是函数式语言外还是一门基于事件驱动的语言，因此语言本身和事件模型浑然天成。  
这个事件模型在前端用的最多（其实后端也基本上都是事件驱动），DOM几乎离不开事件。DOM的事件数不胜数，页面的每个元素都满足这个事件模型。

####CustomEvent
一般情况下事件都是由宿主或程序内部给你定义好的，比如我们常用的`"onclick"`、`"onload"`等等，都是浏览器DOM模型中提供的事件，这些事件类型虽广，不过对于事件驱动编程来说，仍有一部分事件是需要我们自己编程实现的。以前浏览器并没有提供自定义事件的接口，于是开发者们搞出了一个叫**PubSub**（注：发布/订阅。即‘观察者模式’）的设计模式，用来模拟JavaScript的事件机制。虽说表面看起来像是模拟了事件的注册与触发，但究其根本该方法并非弄出一个真正的事件对象，也并没有加入事件的轮询过程，所以相比原生事件模型，PubSub还是有略微缺陷。那是否能够自定义我们自己的事件呢？答案是肯定的。接下来就展示一下如何在浏览器端实现CustomEvent：

	var myEvent = new Event('gamewin');
    //或者用 var myEvent = new CustomEvent('gamewin');
    
    document.addEventListener('gamewin', function (e) {
    	console.log(e.type, "haha~~ I'm Event~");
    });
    
    document.dispatchEvent(myEvent);
    
这里解释一下上面的代码。首先创建了一个Event对象，同时传入一个必需的字符串类型参数，代表事件的`type`，给他起个名字叫“gamewin”，意思是当游戏胜利时。。随后我在`document`对象上添加了一个监听器监听`gamewin`事件。到这里，已經完成自定义事件的声明与注册。接下来就是要触发这个事件：在一个被监听的对象上面调用`dispatchEvent()`方法。然后，你的事件就会压入事件队列并进入事件循环，等队列前面的事件都已经处理完之后，你的Event就被立即触发啦～  
当然喽，自定义的事件没有`on...`的格式，不能像`onclick`等预先定义好的事件一样进行注册。因此只能用最标准的方式`addEventListener()`来注册事件。

####事件冒泡与事件授权
如果某个元素触发一个事件，document对象就会发出一个**事件流**，沿着DOM树流向目标元素（target），沿途的元素就算绑定了事件也不会被执行。当到达了目标元素，就开始执行绑定在它上面的事件处理函数，但如果handle函数没有给定在就不执行。然后从目标元素开始向上级冒泡，如果沿途有相同或包含关系的事件，也会被依次触发。

“源元素”——>“父元素”——>“页面根元素”，这代表的是**事件冒泡**的过程。

因为事件冒泡的存在，让开发者很头疼。事件可能会在一个触发过程中被多次响应：事件在子元素被触发，向上级冒泡，当父元素注册了该事件时也会捕获该到事件，直到根元素Document为止。但也并不是所有的事件都会冒泡。那为什么会有冒泡事件？是因为这么做可以减少驻留在内存和页面中的事件处理器，达到**事件代理**功能以提高性能。

在服务端虽然没有事件冒泡一说，但事件模型随处可见，Node中的核心模块都是建立在事件模型上的，例如最常用的http模块、fs模块，内部是由EventEmiter驱动，EventEmiter负责发射或捕获事件，并将捕获的事件交由CallBack回调函数处理，这也正是异步编程的核心思想。
