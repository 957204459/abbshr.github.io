---
layout: poslay
title: 事件驱动编程与JavaScript
label: 编程范式
kind: label-warning
ptr: 
mdmark: 
metakey: 
metades:
---

###事件驱动的模型

基于事件驱动的程式我们常常接触，尤其是在用户图形界面(GUI)环境中，每单击一次鼠标、敲一下键盘或是当一个模块加载完毕时，都伴随着事件的产生，——操作系统就是个典型的例子。

最近在学习JavaScript的事件模型，再次接触到“事件”这一概念，便整理了一些资料，写了这篇博客，加深理解。

所谓事件驱动的，即：事件的触发导致程式执行。  
在这样一种编程范式中，程式的代码并非像过程化编程那样按“自顶向下、逐步求精”的顺序来执行。因为在事件模型中，每个事件都是随机的、不定发生的，因此开发人员无法预知整个程式将要完成什么任务，所以程式的代码也无法按正常顺序逐步执行。事件驱动编程中代码段的执行靠不同事件的响应来完成，这里有几个事件驱动的模型核心构成：

* 事件注册
* 轮询
* 触发
* 事件处理

事件驱动编程也正是由这几点支撑起来的。  
每个事件在生效前都需要向系统申请**注册**，并编写事件处理函数来**Handle**这个事件。当这个事件被**触发**时，事件处理函数将会被执行。而永无止境的事件**轮询**是完成这一系列动作基础。  
事件驱动编程的关键就在事件的处理上，整个程式的代码都是为了处理相应事件而编写的。

###JavaScript中的事件模型

JavaScript除了是函数式语言外还是一门基于事件驱动的语言，因此语言本身和事件模型浑然天成。  
这个事件模型在前端用的最多（其实后端也基本上都是事件驱动），DOM几乎离不开事件。DOM的事件数不胜数，页面的每个元素都满足这个事件模型。

如果某个元素触发一个事件，document对象就会发出一个**事件流**，沿着DOM树流向目标元素（target），沿途的元素就算绑定了事件也不会被执行。当到达了目标元素，就开始执行绑定在它上面的事件处理函数，但如果handle函数没有给定在就不执行。然后从目标元素开始向上级冒泡，如果沿途有相同或包含关系的事件，也会被依次触发。

“源元素”——>“父元素”——>“页面根元素”，这代表的是**事件冒泡**的过程。

因为事件冒泡的存在，让开发者很头疼。事件可能会在一个触发过程中被多次响应：事件在子元素被触发，向上级冒泡，当父元素注册了该事件时也会捕获该到事件，直到根元素Document为止。但也并不是所有的事件都会冒泡。那为什么会有冒泡事件？是因为这么做可以减少驻留在内存和页面中的事件处理器，达到**事件代理**功能以提高性能。

在服务端虽然没有事件冒泡一说，但事件模型随处可见，Node中的核心模块都是建立在事件模型上的，例如最常用的http模块、fs模块，内部是由EventEmiter驱动，EventEmiter负责发射或捕获事件，并将捕获的事件交由CallBack回调函数处理，这也正是异步编程的核心思想。
